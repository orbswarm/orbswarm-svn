/* ---------------------------------------------------------------------
// 
//	File: scanfrontend.c
//      SWARM Orb SPU code http://www.orbswarm.com
//	
//      Additional code for LEMON-generated parser.
//      Concatenate this with scan.c generated by LEMON from scan.y
//      to generate parser code. See http://www.hwaci.com/sw/lemon/
//
// Something like this: 
//	./lemon scan.y  # (makes scan.c)
//	cat scan.c scanfrontend.c  > scanner.c
//	$(CC) -c -o scanner.o $(CFLAGS) scanner.c
//       See Makefile.
//
//	Written by Jonathan Foote (Head Rotor at rotorbrain.com)
// ----------------------------------------------------------------------- */


/* add next char to command string. If start==1, then start new string 
If token < 0 don't accum token - probably just a signal to just start 
a new string*/
void accumCmd(cmdStruct *c, int token, int start){
  if (start){
    c->cmd_len = 0;
    c->spuAddr = 0;
  }

  if (c->cmd_len >= BUFLENGTH) {
    if(parseDebug)
      fprintf(stderr,"Buffer overflow in accmuCmd()\n");
    return;
  }
  if(token >= 0){
    c->cmd[c->cmd_len++] = (char)token;
    c->cmd[c->cmd_len] = '\0';
  }
  //printf("MCU cmd: %s ",mcu_cmd);
}


/* got the next digit in the spu address, 
   calculate ongoing numerical value */
void accumAddrDigit(int x) {
  spuAddr = 10*spuAddr + (x - '0');
}
/* set spu address to zero before next command */
void resetAddress() {
  spuAddr = 0;
}


/* lexical analyzer for LEMON parser. Determines character type for
   each input char, then passes it to the lemon parser */

void doScanner(void * pParser(), int inChar) {
  /* lexical analyzer for parser */
  if (islower(inChar)  || isupper(inChar)) {
    Parse (pParser, CHAR, inChar); /* got chars [a-zA-Z] */
  }
  else if(isdigit(inChar)) { /* got digits [0-9] */
    Parse (pParser, DIGIT, inChar);
  }
  else if (isblank(inChar)) { /* got whitespace */
    Parse (pParser, WS, inChar);
  }
  else { /* got special chars */
    switch(inChar) {
    case '{':
      Parse (pParser, CMD_START, inChar);
      break;
      case '}':
	Parse (pParser, CMD_END, inChar);
	Parse (pParser, 0, 0);
	resetAddress();
	break;
    case '$':
      Parse (pParser, MCU_START, inChar);
      break;
    case '*':
      Parse (pParser, MCU_END, inChar);
      break;
    case '[':
      Parse (pParser, SPU_START, inChar);
      break;
    case ']':
      Parse (pParser, SPU_END, inChar);
      break;
    case '<':
      Parse (pParser, LED_START, inChar);
      break;
    case '>':
      Parse (pParser, LED_END, inChar);
      break;
    case ',':
    case '.':
    case '-':
      Parse (pParser, CHAR, inChar);
      break;
    case '(':
      Parse(pParser, GPS_START, inChar);
      break;
    case ')':
      Parse(pParser, GPS_END, inChar);
      break;
    case ';':
      Parse (pParser, GPS_DELIM, inChar);
      break;
    case 10: /* that's a  newline) */
             /* which isblank() on the spu misses? */
      Parse (pParser, WS, inChar);
      break;
    case 13: /* that's a <CR>, likely  from windows somewhere. Ignore it. */
      break;	
    case 0:  /* that's a null which means end of input */
      return;
    default:
      if (parseDebug)
	printf("Unexpected char \"%c\" (%x) in input\n", (char)inChar, inChar);
      break;
    }
  }
}

