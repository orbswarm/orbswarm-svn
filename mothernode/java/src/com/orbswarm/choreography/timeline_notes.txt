Some ideas for Timeline algorithm:


* Event class:
    - type
    - name
    - start
    - end (null if n/a)
    - specialist(s)
        - type
        - object
    - data (see Lemuel's email)

    * Types: duration    -- has start, end
             single_shot -- only a start
             action      -- sets properties or runs a
                            specialist command.  
                            (i.e. modifies an existing running specialist)
             sequence    -- see "Chained Actions"


* Basic algorithm
   - context: 
        expects to be given cycles every so often,
        when it gets them, it performs pending actions, does some accounting,
        and then yields control. 
   - maintain two lists, sorted by time
       - Events to start (duration beginnings, single_shots, actions)
       - Events to stop

   - at each cycle:
       - find pending Events to stop;
         stop them;
         take them off the list. (or put them on the accomplished list)
       - find pending events to start;
         start event
           - if has duration, put on list of events-to-stop
           - if is-chained-event, register a commandCompleted callback that
                 runs the rest of the chain. 
           - else put on accomplished list

    - starting events:
       - find the appropriate Specialist class
       - instantiate it, keep pointer in Event
       - set properties based on the Event's properties
       - start it

       
* chained Events...
   - are events that get run in a sequence where the time isn't quite predictable, 
     e.g.: play Sound X; move to Point2304; setColor HSV; play Sound T
   - the sequence gets started at a particular time, and plays the first Event;
     then the next event happens when the first one completes. 
   - when an event in a sequence completes, a callback is called that places the 
     rest of the sequence on the to-be-started list, but with no start time, 
     meaning NOW (or a special token that means NOW) -- where NOW reall means
     the next time the Timeline gets cycles. 

   - Note: for full generality, Sequences should be able to contain other
           sequences, but I'm not sure how easy this kind of recusion is 
           going to be to implement, much less to specify.

   - idea for the callback: place the rest of the sequence (a sequence itself?)
     into a variable on the CommandCompletedListener

   - small bit of squishyness: do command-completed listeners only go on 
     fully-durationed events, or also on commands given to them.
      - e.g. If the RandomSongPlayer is a single Specialist that's long-lived,
             it makes sense to tell it to play a song (an action event),
             then do something after that song completes, even though the 
             Specialist continues on. 
             (If it turns out that Specialist creation/destruction is 
             fast enough, we'll be able to cobble up a new specialist to 
             simply play a song, and not have to worry about that complication)
   

* Display
   - we could make a Timeline display that shows events as horizontal bars
     from their start time to their stop time. Single_shots and actions
     would simply be a start-time glyph. 
   - multiple events that happen at the same time are displayed vertically. 
     (we can probably get by with a simple layout algorithm that arranges them, 
      without having to go to a notion of concurrent tracks). 
   - the display has a zoom-level option:
      - full: all the events are shown, shrunk to fit in the available window
              size. 
      - windowed: the display is enlarged, bigger than the available window, 
                  so we show only a portion at a time.
                  beginning and ending times of the window need to be calculated. 
         * there is a scroll bar to move the visible window around the entire
           Timeline
   - sequences are problematic: we can only display the first one in the right
       place, because the durations are not really known. Perhaps we need a notion
       of estimated time (or else we display them differently).
       * we could also have a notion of actually elapsed time, and use that in the 
         display as the Timeline is running. 

   - events get a different color depending on whether they are in the future, 
     currrently running, or have been accomplished.

   - there's a notion of a current time cursor, that gets updated as the system
     plays. 

   - start/stop are clear; pause/resume are ill-defined (e.g. when we start a 
     sound, we rely on the SPU player to do the pausing for us). 
   - therefore, moving the time cursor and starting from there is undefined if the 
     time cursor starts from within an Event duration.
 
